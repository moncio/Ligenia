import { BaseUseCase } from '../../base/base.use-case';
import { Result } from '../../../../shared/result';
import { z } from 'zod';
import { Player } from '../../../domain/player/player.entity';
import { IPlayerRepository } from '../../interfaces/repositories/player.repository';
import { IUserRepository } from '../../interfaces/repositories/user.repository';
import { PlayerLevel } from '../../../domain/tournament/tournament.entity';

// Input validation schema
const CreatePlayerProfileInputSchema = z.object({
  userId: z.string().uuid({
    message: 'Invalid user ID format',
  }),
  level: z
    .nativeEnum(PlayerLevel, {
      errorMap: () => ({ message: 'Level must be a valid PlayerLevel' }),
    })
    .default(PlayerLevel.P3),
  age: z.number().int().positive().optional().nullable(),
  country: z
    .string()
    .min(2, {
      message: 'Country must be at least 2 characters',
    })
    .optional()
    .nullable(),
  avatarUrl: z
    .string()
    .url({
      message: 'Avatar URL must be a valid URL',
    })
    .optional()
    .nullable(),
});

// Input type
export type CreatePlayerProfileInput = z.infer<typeof CreatePlayerProfileInputSchema>;

// Output type
export interface CreatePlayerProfileOutput {
  player: Player;
}

/**
 * Use case for creating a player profile
 */
export class CreatePlayerProfileUseCase extends BaseUseCase<
  CreatePlayerProfileInput,
  CreatePlayerProfileOutput
> {
  constructor(
    private readonly playerRepository: IPlayerRepository,
    private readonly userRepository: IUserRepository,
  ) {
    super();
  }

  protected async executeImpl(
    input: CreatePlayerProfileInput,
  ): Promise<Result<CreatePlayerProfileOutput>> {
    try {
      // Validate input first
      let validatedData: CreatePlayerProfileInput;
      try {
        validatedData = await CreatePlayerProfileInputSchema.parseAsync(input);
      } catch (validationError) {
        if (validationError instanceof z.ZodError) {
          return Result.fail<CreatePlayerProfileOutput>(
            new Error(validationError.errors[0].message),
          );
        }
        throw validationError;
      }

      // Check if user exists
      const user = await this.userRepository.findById(validatedData.userId);
      if (!user) {
        return Result.fail<CreatePlayerProfileOutput>(new Error('User not found'));
      }

      // Check if player already exists for this user
      const existingPlayer = await this.playerRepository.findByUserId(validatedData.userId);
      if (existingPlayer) {
        return Result.fail<CreatePlayerProfileOutput>(
          new Error('Player profile already exists for this user'),
        );
      }

      // Create player entity
      const player = new Player(
        '', // ID will be generated by the repository
        validatedData.userId,
        validatedData.level,
        validatedData.age,
        validatedData.country,
        validatedData.avatarUrl,
      );

      // Save player
      console.log('Attempting to save player:', JSON.stringify({
        userId: player.userId,
        level: player.level,
        age: player.age,
        country: player.country,
        avatarUrl: player.avatarUrl
      }));
      
      try {
        await this.playerRepository.save(player);
        console.log('Player saved successfully:', player.id);
      } catch (saveError) {
        console.error('Error saving player:', saveError);
        return Result.fail<CreatePlayerProfileOutput>(
          new Error(`Failed to save player profile: ${saveError instanceof Error ? saveError.message : 'Unknown error'}`),
        );
      }

      return Result.ok<CreatePlayerProfileOutput>({ player });
    } catch (error) {
      console.error('Unhandled error in CreatePlayerProfileUseCase:', error);
      return Result.fail<CreatePlayerProfileOutput>(
        error instanceof Error ? error : new Error('Failed to create player profile: ' + (error ? error.toString() : 'Unknown error')),
      );
    }
  }
}
